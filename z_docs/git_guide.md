# Git 협업 가이드

## 목차
1. [Git 소개](#git-소개)
2. [Git 설치 및 초기 설정](#git-설치-및-초기-설정)
3. [기본 Git 명령어](#기본-git-명령어)
4. [브랜치 전략](#브랜치-전략)
5. [협업 워크플로우](#협업-워크플로우)
6. [원격 브랜치 관리](#원격-브랜치-관리)
7. [자주 발생하는 문제와 해결 방법](#자주-발생하는-문제와-해결-방법)
8. [Git 사용 시 모범 사례](#git-사용-시-모범-사례)

## Git 소개

### Git이란?
Git은 소스 코드의 버전을 관리하는 분산형 버전 관리 시스템입니다. 여러 개발자가 동시에 작업할 수 있게 해주며, 코드의 변경 사항을 추적하고 필요할 때 이전 버전으로 되돌릴 수 있습니다.

### Git을 사용하는 이유
- **변경 이력 추적**: 누가, 언제, 무엇을 변경했는지 기록됩니다.
- **협업**: 여러 개발자가 동시에 작업할 수 있습니다.
- **백업**: 코드가 원격 저장소에 저장되어 안전하게 보관됩니다.
- **실험**: 새로운 기능을 별도의 브랜치에서 안전하게 개발할 수 있습니다.

## Git 설치 및 초기 설정

### Git 설치
1. [Git 공식 웹사이트](https://git-scm.com/downloads)에서 운영체제에 맞는 Git을 다운로드하고 설치합니다.
2. 설치가 완료되면 터미널(맥/리눅스) 또는 명령 프롬프트(윈도우)를 열고 다음 명령어로 설치를 확인합니다:
   ```
   git --version
   ```

### 초기 설정
Git을 처음 사용할 때는 사용자 정보를 설정해야 합니다:
```
git config --global user.name "홍길동"
git config --global user.email "hong@example.com"
```

## 기본 Git 명령어

### 저장소 초기화 및 복제
- **새 저장소 초기화**: `git init`
- **원격 저장소 복제**: `git clone [URL]`
  ```
  git clone https://github.com/username/changple.git
  ```

### 변경 사항 관리
- **변경 사항 확인**: `git status`
- **변경 사항 스테이징**: `git add [파일명]` 또는 모든 변경 사항을 스테이징하려면 `git add .`
- **변경 사항 커밋**: `git commit -m "커밋 메시지"`
- **변경 이력 확인**: `git log`

### 원격 저장소 작업
- **원격 저장소 추가**: `git remote add origin [URL]`
- **변경 사항 업로드**: `git push origin [브랜치명]`
- **원격 저장소에서 변경 사항 가져오기**: `git pull origin [브랜치명]`
- **원격 저장소의 변경 사항 확인만 하기**: `git fetch origin`

### 브랜치 관리
- **브랜치 목록 확인**: `git branch`
- **새 브랜치 생성**: `git branch [브랜치명]`
- **브랜치 전환**: `git checkout [브랜치명]`
- **브랜치 생성 및 전환 동시에**: `git checkout -b [브랜치명]`
- **브랜치 병합**: `git merge [브랜치명]`
- **브랜치 삭제**: `git branch -d [브랜치명]`

## 브랜치 전략

창플 AI 챗봇 프로젝트에서는 다음과 같은 브랜치 전략을 사용합니다:

### 주요 브랜치
- **develop**: 기본 개발 브랜치이자 GitHub 저장소의 기본(default) 브랜치입니다. 모든 개발 작업은 이 브랜치에서 시작하고 이 브랜치로 병합됩니다.
- **main**: 제품 출시 가능한 안정적인 상태의 코드가 있는 브랜치입니다. develop 브랜치에서 충분히 테스트된 코드만 이 브랜치로 병합됩니다.

### 보조 브랜치
- **feature/[기능명]**: 새로운 기능 개발을 위한 브랜치 (예: `feature/login`, `feature/chat-interface`)
- **bugfix/[버그명]**: 버그 수정을 위한 브랜치
- **hotfix/[핫픽스명]**: 긴급 수정을 위한 브랜치

### 브랜치 생명주기
1. develop 브랜치에서 새 기능 브랜치 생성
2. 기능 개발 및 테스트
3. develop 브랜치로 Pull Request 및 병합
4. 병합 완료 후 기능 브랜치 삭제 (로컬 및 원격)
5. 충분한 기능이 개발되면 develop에서 main으로 병합

## 협업 워크플로우

### 기본 워크플로우
1. **최신 코드 가져오기**:
   ```
   git checkout develop
   git pull origin develop
   ```

2. **새 기능 브랜치 생성**:
   ```
   git checkout -b feature/새기능
   ```

3. **코드 작성 및 커밋**:
   ```
   # 코드 작성 후
   git add .
   git commit -m "새 기능 구현: 로그인 페이지 디자인"
   ```

4. **원격 저장소에 푸시**:
   ```
   git push origin feature/새기능
   ```

5. **Pull Request 생성**:
   - GitHub에서 `feature/새기능` 브랜치에서 `develop` 브랜치로 Pull Request를 생성합니다.
   - 코드 리뷰 후 승인되면 병합됩니다.

6. **브랜치 정리**:
   ```
   git checkout develop
   git pull origin develop
   git branch -d feature/새기능
   ```

### 일일 작업 시작 전
항상 최신 코드로 시작하세요:
```
git checkout develop
git pull origin develop
git checkout 작업브랜치
git merge develop
```

## 원격 브랜치 관리

### 원격 브랜치 확인
원격 저장소의 브랜치 목록을 확인합니다:
```
git branch -r
```

### 원격 브랜치 가져오기
원격 브랜치를 로컬로 가져와 작업하려면:
```
git checkout -b 로컬브랜치명 origin/원격브랜치명
```
예: `git checkout -b feature/login origin/feature/login`

### 원격 브랜치 삭제
PR이 완료되고 develop 브랜치에 병합된 후에는 원격 feature 브랜치를 삭제하는 것이 좋습니다:
```
git push origin --delete feature/기능명
```

### 원격 브랜치 참조 정리
원격에서 삭제된 브랜치의 로컬 참조를 정리합니다:
```
git fetch --prune
```
또는
```
git remote prune origin
```

### 브랜치 관리 모범 사례
- PR이 완료되고 병합된 feature 브랜치는 로컬과 원격 모두에서 삭제합니다.
- 주기적으로 원격 브랜치를 정리하여 저장소를 깔끔하게 유지합니다.
- 장기적인 개발 브랜치나 릴리스 브랜치는 유지할 수 있습니다.
- 브랜치 삭제 전에 해당 브랜치의 변경사항이 모두 병합되었는지 확인합니다.

### 원격 브랜치 삭제 워크플로우
1. PR 생성 및 코드 리뷰
2. develop 브랜치로 병합 완료
3. 로컬 브랜치 삭제: `git branch -d feature/기능명`
4. 원격 브랜치 삭제: `git push origin --delete feature/기능명`
5. 원격 참조 정리: `git fetch --prune`

## 자주 발생하는 문제와 해결 방법

### 충돌(Conflict) 해결
충돌이 발생하면 Git이 충돌 파일에 표시를 해둡니다. 다음과 같이 해결합니다:

1. 충돌 파일을 열어 충돌 부분을 확인합니다 (`<<<<<<<`, `=======`, `>>>>>>>` 표시 사이).
2. 코드를 수정하여 충돌을 해결합니다.
3. 충돌 표시를 모두 제거합니다.
4. 변경 사항을 저장하고 커밋합니다:
   ```
   git add .
   git commit -m "충돌 해결"
   ```

#### 충돌에 대한 이해
충돌은 두 개의 브랜치가 같은 파일의 같은 부분을 서로 다르게 수정했을 때 발생합니다. Git은 자동으로 어떤 변경을 선택해야 할지 결정할 수 없어 사용자의 개입이 필요합니다.

#### 충돌 표시 이해하기
Git은 충돌 영역을 다음과 같이 표시합니다:
```
병합하려는 브랜치의 코드
```

#### 충돌 예방하기
- **자주 pull 받기**: 팀원들의 변경 사항을 자주 가져와 작업하면 충돌 가능성이 줄어듭니다.
- **작은 단위로 커밋하기**: 큰 변경보다 작은 변경을 자주 커밋하면 충돌 해결이 쉬워집니다.
- **파일 분리하기**: 가능하면 팀원들과 같은 파일을 동시에 수정하지 않도록 작업을 분리합니다.
- **커뮤니케이션**: 팀원들과 작업 영역에 대해 소통하여 같은 파일 수정을 피합니다.

#### 충돌 해결 도구 사용하기
많은 IDE와 도구들이 충돌 해결을 시각적으로 도와줍니다:
- **VS Code**: 충돌을 색상으로 표시하고 "Accept Current Change", "Accept Incoming Change", "Accept Both Changes" 버튼을 제공합니다.
- **IntelliJ IDEA, WebStorm**: 충돌 해결을 위한 3방향 병합 도구를 제공합니다.
- **GitHub Desktop**: 충돌이 발생한 파일을 시각적으로 보여주고 해결 도구를 제공합니다.
- **git mergetool**: 터미널에서 `git mergetool` 명령어로 설정된 병합 도구를 실행할 수 있습니다.

#### 복잡한 충돌 해결하기
1. **충돌 이해하기**: 두 변경 사항의 의도를 이해하는 것이 중요합니다.
2. **테스트 실행**: 충돌 해결 후 코드가 제대로 작동하는지 테스트합니다.
3. **팀원과 상의**: 불확실한 경우 해당 코드를 작성한 팀원과 상의합니다.
4. **병합 중단**: 복잡한 충돌이 발생하면 `git merge --abort`로 병합을 취소하고 다시 시도할 수 있습니다.

#### 특수한 충돌 상황 해결
- **이진 파일 충돌**: 이미지나 PDF 같은 이진 파일은 병합이 어렵습니다. `git checkout --ours 파일명` 또는 `git checkout --theirs 파일명`으로 한쪽 버전을 선택할 수 있습니다.
- **삭제된 파일 충돌**: 한쪽에서 파일을 수정하고 다른쪽에서 삭제한 경우, 파일을 유지할지 삭제할지 결정해야 합니다.
- **파일 이름 변경 충돌**: 양쪽에서 같은 파일의 이름을 다르게 변경한 경우 복잡한 충돌이 발생할 수 있습니다.

#### 충돌 해결 후 작업
충돌을 해결한 후에는:
1. 변경 사항을 스테이징: `git add .`
2. 충돌 해결 커밋: `git commit -m "충돌 해결: 설명"`
3. 필요하면 테스트 실행
4. 원격 저장소에 푸시: `git push origin 브랜치명`

#### rebase 충돌 해결
rebase 과정에서 충돌이 발생할 경우:
1. 충돌 해결 후 `git add .`
2. `git rebase --continue`로 rebase 계속 진행
3. 중단하려면 `git rebase --abort`

#### Pull Request(PR) 과정에서 충돌 해결하기
GitHub에서 PR을 생성할 때 충돌이 발생하면 다음 두 가지 방법으로 해결할 수 있습니다:

##### GitHub 웹 인터페이스에서 해결하기
1. GitHub PR 페이지에서 "Resolve conflicts" 버튼이 표시된 경우:
   - 버튼을 클릭하면 웹 에디터가 열립니다.
   - 충돌 부분을 수정합니다. (`<<<<<<<`, `=======`, `>>>>>>>` 마커를 모두 제거해야 합니다)
   - "Mark as resolved" 버튼을 클릭한 후 "Commit merge" 버튼을 클릭합니다.

2. 장점: 간단한 충돌은 빠르게 해결할 수 있습니다.
3. 단점: 복잡한 충돌이나 여러 파일에 걸친 충돌을 해결하기 어렵습니다.

##### 로컬에서 해결하기 (권장)
1. PR을 생성한 후 GitHub에서 충돌이 발생했다는 메시지가 표시되면:
   ```
   git checkout develop           # 대상 브랜치 체크아웃
   git pull origin develop        # 최신 상태로 업데이트
   git checkout feature/기능명     # 작업 브랜치 체크아웃
   git merge develop             # develop 브랜치 병합 시도
   ```

2. 충돌이 발생하면 각 파일의 충돌을 해결합니다.
3. 충돌 해결 후:
   ```
   git add .
   git commit -m "충돌 해결: 설명"
   git push origin feature/기능명
   ```

4. 이제 GitHub PR 페이지를 새로고침하면 충돌이 해결되었다는 메시지가 표시됩니다.

##### PR 충돌 해결 팁
- PR을 생성하기 전에 대상 브랜치(보통 develop)의 최신 변경사항을 먼저 병합하여 충돌을 미리 해결하는 것이 좋습니다.
- 충돌이 복잡하거나 많은 경우, 로컬에서 해결하는 것이 항상 더 안전합니다.
- 충돌 해결 후에는 코드가 제대로 작동하는지 테스트가 중요합니다.
- 충돌 해결 커밋 메시지에는 어떤 충돌을 어떻게 해결했는지 명확하게 기록하세요.
- 불확실한 충돌은 해당 코드를 작성한 팀원과 상의하는 것이 좋습니다.

### 실수로 변경한 내용 되돌리기
- **스테이징되지 않은 변경 사항 되돌리기**: `git checkout -- [파일명]`
- **스테이징된 변경 사항 되돌리기**: `git reset HEAD [파일명]` 후 `git checkout -- [파일명]`
- **마지막 커밋 수정**: `git commit --amend`
- **이전 커밋으로 되돌리기**: `git reset --hard HEAD~1` (주의: 변경 사항이 완전히 삭제됨)

### 원격 브랜치와 로컬 브랜치 동기화
```
git fetch origin
git reset --hard origin/브랜치명
```
(주의: 로컬 변경 사항이 모두 삭제됩니다)

## Git 사용 시 모범 사례

### 커밋 메시지 작성 규칙
좋은 커밋 메시지는 다음과 같은 형식을 따릅니다:
```
[유형]: 간결한 변경 내용 요약 (50자 이내)

- 상세 설명 1
- 상세 설명 2
```

유형 예시:
- **feat**: 새로운 기능 추가
- **fix**: 버그 수정
- **docs**: 문서 변경
- **style**: 코드 포맷팅, 세미콜론 누락 등 (코드 변경 없음)
- **refactor**: 코드 리팩토링
- **test**: 테스트 코드 추가/수정
- **chore**: 빌드 프로세스 변경, 패키지 매니저 설정 등

### 자주 커밋하기
작은 단위로 자주 커밋하면 변경 사항을 추적하기 쉽고, 문제가 발생했을 때 되돌리기 쉽습니다.

### Pull Request 전 확인사항
- 코드가 제대로 작동하는지 테스트했나요?
- 불필요한 주석이나 디버깅 코드를 제거했나요?
- 코드 스타일 가이드를 준수했나요?
- 필요한 문서를 업데이트했나요?

### 브랜치 관리
- 작업이 완료된 브랜치는 로컬과 원격 모두에서 삭제하여 저장소를 깔끔하게 유지합니다.
- 오래된 브랜치는 주기적으로 최신 `develop` 브랜치와 동기화합니다.
- PR 병합 후에는 해당 feature 브랜치를 삭제하는 습관을 들입니다.
- 기본 브랜치인 develop에 직접 커밋하지 않고 항상 feature 브랜치를 통해 작업합니다.

## 도움이 필요하시면
Git에 대해 더 알고 싶거나 문제가 발생하면 팀원에게 물어보거나 다음 자료를 참고하세요:
- [Git 공식 문서](https://git-scm.com/doc)
- [GitHub 도움말](https://help.github.com/)
- [Pro Git 책 (한글)](https://git-scm.com/book/ko/v2)

---

이 가이드는 창플 AI 챗봇 프로젝트의 Git 협업을 위해 작성되었습니다. 
추가 질문이나 제안사항이 있으면 팀 리더에게 문의해 주세요. 